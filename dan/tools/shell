#!/usr/bin/env perl
use warnings;  
use strict;  

use AnyEvent;  
use AnyEvent::Impl::Perl;  
use AnyEvent::Socket;  
use AnyEvent::Handle;  
  
use MYDan::API::Agent;
use MYDan::Agent::Query;
use MYDan::Util::OptConf;
use IO::Socket;
use Term::ReadKey;
use POSIX qw( :sys_wait_h );

$| ++;

=head1 SYNOPSIS

 $0 --host host

    get a shell from remote machine

 $0 --host host --listen 9999

 $0 --host host --listen 9999 [--addr 10.10.10.1]\
      [--user user(default `logname`)] [--sudo sudoer]

=cut

$MYDan::Util::OptConf::THIS = 'agent';
my $option = MYDan::Util::OptConf->load();
my %o = $option->get( qw( host=s listen=i addr=s user=s sudo=s ) )->dump();
$option->assert( 'host' );

my $cv = AE::cv;  

my $listen = $o{listen};

unless( $listen )
{
    my $scan = `nc -z localhost 65111-65333`;
    my %open = map{ $_ => 1 }my @open = $scan =~ / (\d+) /g;
    ( $listen ) = grep{ ! $open{$_} }65111 .. 65333 ;
}

if ( fork ) {
    my $handle;
    $|++;
    my $socket = IO::Socket::INET->new (
        LocalPort => $o{listen},
        LocalAddr => $o{addr},
        Type      => SOCK_STREAM,
        Reuse     => 1,
        Listen    => 1
    ) or die "Could not connect to $o{addr} on Port $o{listen}: $!";
    $handle = $socket->accept();
    $handle->autoflush();

    defined (my $child = fork()) or die "Could not fork: $!";
    my $char;
    ReadMode(4);
    if ($child) {
        close( STDIN );
        while ( my $byte = sysread( $handle, my $char, 1024 )) {
            syswrite( STDOUT, $char, $byte );
        }
        print "exit done\n";
        exit 1;
    } else {
        close( STDOUT );
        while (my $byte = sysread( STDIN, my $char, 1024 )) {
            syswrite( $handle, $char, $byte );
        }
        waitpid(-1, WNOHANG);
        exit 1;
    }
}
print "listen shell on:$listen\n";

close( STDIN );
close( STDOUT );

$o{user} = `logname` and chop $o{user}  unless $o{user};

my %query = (
    code => 'shell',
    argv => [ $o{addr}, $listen ],
    map{ $_ => $o{$_} }qw( user sudo )
);

my $isc = $o{role} && $o{role} eq 'client' ? 1 : 0;
$query{node} = [ $o{host}] if $isc;
my $query = MYDan::Agent::Query->dump( \%query );

eval{ $query = MYDan::API::Agent->new()->encryption( $query ) if $isc };
die "encryption fail:$@" if $@;

tcp_connect $o{host}, $o{port}, sub {  
   my ( $fh ) = @_  or die "tcp_connect: $!";  
   my $hdl; $hdl = new AnyEvent::Handle( 
       fh => $fh,
       on_read => sub {
           my $self = shift;
           $self->unshift_read (
               chunk => length $self->{rbuf},
               sub {}
           );
       },
       on_eof => sub{
           undef $hdl;
           $cv->send;  
       }
   );  

   $hdl->push_write($query);  
   $hdl->push_shutdown;
};  

$cv->recv;  
exit 0;
