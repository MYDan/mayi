#!/usr/bin/env perl
use strict;
use warnings;
use YAML::XS;
use IO::Socket;
use IO::Pty;
use IO::Poll qw( POLLIN POLLHUP POLLOUT POLLERR);

$|++;
local $/ = undef;

my %param = %{ YAML::XS::Load( <> ) };

my( $host, $port ) = @{$param{argv}};
$host ||= $ENV{HOSTNAME};

die "nofind user" unless my $user = $ENV{MYDan_sudo} ||  $ENV{MYDan_user};
die "nofind user home" unless my $dir = ( getpwnam $user )[7];

$ENV{HISTORY_FILE}="$dir/.bash_history";

map{ die "param error" unless $_ }( $host, $port );

my $socket = IO::Socket::INET->new(
    PeerAddr => $host,
    PeerPort => $port,
    Proto    => 'tcp'
);

my $pty = exec_cmd('/bin/bash -i');

$socket->blocking(0);
$pty->blocking(0);
my $poll = IO::Poll->new();
$poll->mask( $socket => POLLIN  );
$poll->mask( $pty => POLLIN );

while ( $poll->handles && $socket ) {
    $poll->poll();
    for my $handle ( $poll->handles( POLLIN ) ) {
        if ( $handle eq $socket ) {
            my $data;
            if ( my $byte = sysread( $socket, $data, 1024 ) ) {
                syswrite( $pty, $data, $byte );
            }
        }
        elsif ( $handle eq $pty ) {
            my $data;
            if ( my $byte = sysread( $pty, $data, 1024 ) ) {
                syswrite( $socket, $data, $byte );
            }
        }
    }
    if ( $poll->handles( POLLHUP | POLLERR) ) {
        $socket->shutdown( 2 );
    }
}

sub exec_cmd {
    my $cmd = shift;
    my $pty = IO::Pty->new();

    close( STDIN );
    close( STDOUT );
    close( STDERR );
    if ( my $child = fork ) {
        $pty->close_slave();
        return $pty;
    }

    POSIX::setsid();
    my $slave = $pty->slave();
    close( $pty );

    open(STDIN,  "<&"  .  $slave->fileno());
    open(STDOUT, ">&" . $slave->fileno());
    open(STDERR, ">&" . $slave->fileno());
    exec( $cmd );
}

exit 1;

