#!/usr/bin/env perl
use strict;
use warnings;
use YAML::XS;
use MYDan::Agent::Query;
use Time::HiRes qw(time);
use AnyEvent;
use AnyEvent::Impl::Perl;
use AnyEvent::Socket;
use AnyEvent::Handle;
use Fcntl qw(:flock SEEK_END);
 
use Digest::MD5;

eval{

    local $/ = undef;
    my (  %param, $i ) = %{ YAML::XS::Load( <> ) };
    my ( $param ) = @{$param{argv}};
    
    die "agent/code/download argv no hash" unless $param && ref $param eq 'HASH';
    
    map{ 
        die "agent/code/download $_ undef" unless $param->{$_};
    }qw( load src port sp dp );
    
    open my $TMP, '+>', "$param->{dp}.$$.tmp" or die "Can't open '$param->{dp}.$$.tmp': $!";

    my ( $cv, $len, %keepalive ) = ( AE::cv, 0, cont => '', skip => 0, first => 1 );

    tcp_connect $param->{src}, $param->{port}, sub {
       my ( $fh ) = @_  or die "tcp_connect: $!";
       my $hdl; $hdl = new AnyEvent::Handle(
               fh => $fh,
               on_read => sub {
                   my $self = shift;
                   $self->unshift_read (
                       chunk => length $self->{rbuf},
                       sub {
 
                            if( $keepalive{first} && $_[1] !~ /^\*/ )
                            {
                                 $keepalive{first} = 0;
                                 $keepalive{skip} = 1;
                            }

                            if( $keepalive{skip} )
                            {
                                $len += length $_[1];
                                print $TMP $_[1];
                            }
                            else
                            {
                                $keepalive{cont} .= $_[1];
                                $keepalive{cont} =~ s/^\*+//g;
                                if( $keepalive{cont} =~ s/^#\*keepalive\*#// )
                                {
                                    $keepalive{skip} = 1;
                                    $len += length $keepalive{cont};
                                    print $TMP $keepalive{cont};
                                }
                            }
                        }

                   );
                },
                on_eof => sub{
                    undef $hdl;
                     $cv->send;
                 }
       );
       $hdl->push_write($param->{load});
       $hdl->push_shutdown;
    };
    $cv->recv;


    seek( $TMP, -38, SEEK_END );
    my $end = ''; while( <$TMP> ) { $end .= $_; }
    my @end = $end =~ /^([0-9a-z]{32})--- (\d+)\n/;
    unless( defined $end[1] && $end[1] == 0 )
    {
        unlink  "$param->{dp}.$$.tmp";
        die "call agent fail: end=$end\n";
    }
    truncate $TMP, $len - 38;
    seek $TMP, 0, 0;
    my $md5 = Digest::MD5->new()->addfile( $TMP )->hexdigest();
    unless( defined $end[0] && $end[0] eq $md5 )
    {
        unlink  "$param->{dp}.$$.tmp";
        die "md5 nomatch\n";
    }
    rename "$param->{dp}.$$.tmp", $param->{dp};
};

if($@) { print "load fail $@";exit 1; }

exit 0;

