#!# perl: deploy/code/b.node
use strict;
use File::Spec;
use Sys::Hostname;

use MYDan::Util::AlarmDB;
use Data::Dumper;
use MYDan::Agent::Client;
use MYDan::Node;

my $path;
BEGIN{
    my %deploy = MYDan::Util::OptConf->load()->dump('deploy');
    die  'no path to alarm' unless $deploy{alarm} && -d $deploy{alarm};
    $path = $deploy{alarm};
};

our %type = ( sys => 1, app => 1, lvs => 1 );

return sub
{
    my %param = @_;

    my ( $batch, $param ) = @param{qw( batch param )};

    my $alarm = $param->{alarm} || 'off';
    my $type = $param->{type} || [ 'app' ];
    $type = [ $type ] unless ref $type;

    my $range = MYDan::Node->new( MYDan::Util::OptConf->load()->dump( 'range') );
    my $db = $range->db;


    for my $t ( grep{ $type{$_} }@$type )
    {
        my $alarmdb = MYDan::Util::AlarmDB->new( sprintf( "%s_%s", $$, $t ) => $path );

        my @node = @{$param{batch}};

        if( $t eq 'lvs' )
        {
            my ( %node, %c, %lvs );

            for my $node ( @node )
            {
                next if $node{$node};

                my @cluster = $db->select( 'name,attr', node => [ 1, $node ] );
                for my $cluster ( @cluster )
                {
                    my ( $name, $attr ) = @$cluster;
                    $c{$name}{$attr} = 1;

                    my @n = $db->select( 'node', name => [ 1, $name ], attr => [ 1, $attr ] );
                    map{ $node{$_} = 1 }map{ @$_ }@n;
                }
            }

            for my $name ( keys %c )
            {
                for my $attr ( keys %{$c{$name}} )
                {
                    my @lvs = $db->select( 'node', name => [ 1, $name ], attr => [ 1, "lvs_$attr" ] );
                    map{ $lvs{$_} = 1 }map{ @$_ }@lvs;
                }
            }

            @node = keys %lvs;
        }

        $alarm eq 'off' ? $alarmdb->off( @node) : $alarmdb->on( @node );
    }
    return map{ $_ => 1 }@{$param{batch}};
};
